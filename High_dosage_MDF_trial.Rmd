---
title: "High inclusion of beta-mannnan trial"
author: "Shashank Gupta"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true # table of content true
    toc_depth: 4  # upto three depths of headings (specified by #, ## and ###)
    number_sections: true  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
---

```{r, include=FALSE}
options(tinytex.verbose = TRUE)
```

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

Load all the packages
```{r message=FALSE, warning=FALSE}
library("ranacapa")
library("phyloseq")
library("ggplot2")
library("stringr")
library("plyr")
library("reshape2")
library("reshape")
library("dplyr")
library("tidyr")
library("doBy")
library("plyr")
library("microbiome")
library("ggpubr")
library("vegan")
library("tidyverse")
library("magrittr")
library("cowplot")
library("dendextend")
library("WGCNA")
library("metagenomeSeq")
library("decontam")
library("RColorBrewer")
library("ampvis2")
library("ggpubr")
library("formatR")
library("DT")
library("taxcleanr") #devtools::install_github("shashank-KU/taxcleanr")
library("pheatmap")
library("DESeq2")
library("microbiomeMarker")

```

# Overview of the multi-omics
![](/Users/shashankgupta/Desktop/ImprovAFish/Final_Figures/Trial.png)

# Sampling for low inclusion of beta-mannnan trial
![](https://raw.githubusercontent.com/shashank-KU/ImprovaFish-MDF-Effects/main/Images/Trial_2.png)

# Phenotypic scoring
```{r}
# Specify the path to your CSV file on GitHub
csv_file <- "Phenotypic/Metrics_high_dosage.csv"
csv_url <- paste0("https://raw.githubusercontent.com/shashank-KU/ImprovaFish-MDF-Effects/main/", csv_file)

# Read the CSV file
fish_data <- read.csv(url(csv_url), row.names = 1)

fish_data$Diet <- factor(fish_data$Diet, levels=c('CTR', '4%MN3'))
annotation_colors <- list(
  Diet = c(`CTR`="#e41a1cff", `4%MN3`="#984EA3"))

plot_2A <- ggboxplot(fish_data, x = "Diet", y = "Body.weight",
          color = "black", palette = "jco", legend = "none", outlier.shape = NA)+ 
  #stat_compare_means(comparisons = my_comparisons, hide.ns = F) +
  stat_compare_means(label.y = 370) +
  ggplot2::geom_jitter(
    mapping = aes_string(fill="Diet"),
    position = ggplot2::position_jitter(seed=123), 
    shape = 21,
    color = "black",
    size = 2,
    alpha = 0.8
  ) +
  theme_bw() +   ylab("Body weight") +
  theme(legend.position="none",axis.title.x=element_blank()) +
  scale_fill_manual(values =  annotation_colors$Diet) + 
  scale_colour_manual( values = annotation_colors$Diet)
```

```{r, warning=FALSE}
# fish_data %>%
#     complete(Timepoint, Diet, fill = list(BW = NA, Length = NA)) %>%
#     group_by(Timepoint, Diet) %>%
#     summarise(across(c(Heart_Score, Fat_Score,cataract_V,cataract_H  ), mean, na.rm = TRUE), .groups = 'drop') %>%
#     mutate(across(where(is.numeric), round, 2)) %>%
#     DT::datatable()

library(dplyr)
library(tidyr)

fish_data %>%
  complete(Diet, fill = list(Body.weight = NA, Length = NA, GW = NA, CF = NA, HSI = NA, CSI = NA, Heart_W= NA,Liver_W = NA)) %>%
  group_by(Diet) %>%
  summarise(
    Mean_BW = mean(Body.weight, na.rm = TRUE),
    Mean_Length = mean(Length, na.rm = TRUE),
    Mean_GW = mean(GW, na.rm = TRUE),
    Mean_CF = mean(CF, na.rm = TRUE),
    Mean_HSI = mean(HSI, na.rm = TRUE),
    Mean_CSI = mean(CSI, na.rm = TRUE),
    Mean_Heart_W = mean(Heart_W, na.rm = TRUE),
    Mean_Liver_W = mean(Liver_W, na.rm = TRUE),
    SEM_BW = sd(Body.weight, na.rm = TRUE) / sqrt(sum(!is.na(Body.weight))),
    SEM_Length = sd(Length, na.rm = TRUE) / sqrt(sum(!is.na(Length))),
    SEM_GW = sd(GW, na.rm = TRUE) / sqrt(sum(!is.na(GW))),
    SEM_CF = sd(CF, na.rm = TRUE) / sqrt(sum(!is.na(CF))),
    SEM_HSI = sd(HSI, na.rm = TRUE) / sqrt(sum(!is.na(HSI))),
    SEM_CSI = sd(CSI, na.rm = TRUE) / sqrt(sum(!is.na(CSI))),
    SEM_Heart_W = sd(Heart_W, na.rm = TRUE) / sqrt(sum(!is.na(Heart_W))),
    SEM_Liver_W = sd(Liver_W, na.rm = TRUE) / sqrt(sum(!is.na(Liver_W))),

    .groups = 'drop'
  ) %>%
  mutate(
    across(where(is.numeric), ~round(., 2)),
    across(starts_with("Mean_"), ~paste(., "Â±", get(paste0("SEM_", sub("Mean_", "", cur_column())))))
  ) %>%
  filter(complete.cases(.)) %>%
  select(Diet, starts_with("Mean_"), -starts_with("SEM_")) %>%
  rename_with(~sub("Mean_", "", .), starts_with("Mean_")) %>%
  DT::datatable()
```

# Metagenomics
Import data and clean the taxonomy
```{r warning=FALSE, message=FALSE}
# Load data
base_url <- "https://raw.githubusercontent.com/shashank-KU/ImprovaFish-MDF-Effects/main/"
# Specify the path to your RDS file on GitHub
rds_file <- "Metagenomics/high_dosage_trial/metagenomics_high_MDF.rdata"
rds_url <- paste0(base_url, rds_file)
# Read the RDS file
all <- readRDS(url(rds_url))

tax <- data.frame(tax_table(all), stringsAsFactors = FALSE)
tax <- tax[,1:7] # No info in col 8-15
# Set informative colnames
colnames(tax) <- c("Kingdom", "Phylum","Class","Order","Family","Genus", "Species")
library(stringr)
tax.clean <- data.frame(row.names = row.names(tax),
                        Kingdom = str_replace(tax[,1], "d__",""), 
                        Phylum = str_replace(tax[,2], "p__",""),
                        Class = str_replace(tax[,3], "c__",""),
                        Order = str_replace(tax[,4], "o__",""),
                        Family = str_replace(tax[,5], "f__",""),
                        Genus = str_replace(tax[,6], "g__",""),
                        Species = str_replace(tax[,7], "s__",""), 
                        stringsAsFactors = FALSE)
tax.clean[is.na(tax.clean)] <- ""
tax.clean[tax.clean$Phylum %in% c("uncultured"),2:8] <- ""
out <- c("uncultured")
tax.clean[tax.clean$Class %in% out, 3:8] <- ""
tax.clean[tax.clean$Order %in% out, 4:8] <- ""
tax.clean[tax.clean$Family %in% out, 5:8] <- ""
tax.clean[tax.clean$Genus %in% out, 6:8] <- ""
tax.clean[tax.clean$Species %in% out, 7:8] <- ""

# Remove remove ".", change "-" and " " to "_"
for (i in 1:ncol(tax.clean)){
  tax.clean[,i] <- str_replace_all(tax.clean[,i], "[.]","")
  tax.clean[,i] <- str_replace_all(tax.clean[,i], "[(]","")
  tax.clean[,i] <- str_replace_all(tax.clean[,i], "[)]","")
  tax.clean[,i] <- str_replace_all(tax.clean[,i], "-","_")
  tax.clean[,i] <- str_replace_all(tax.clean[,i], " ","_")
}

for (i in 1:7){ tax.clean[,i] <- as.character(tax.clean[,i])}
# File holes in the tax table
for (i in 1:nrow(tax.clean)){
  #  Fill in missing taxonomy
  if (tax.clean[i,2] == ""){
    kingdom <- paste("Kingdom_", tax.clean[i,1], sep = "")
    tax.clean[i, 2:7] <- kingdom
  } else if (tax.clean[i,3] == ""){
    phylum <- paste("Phylum_", tax.clean[i,2], sep = "")
    tax.clean[i, 3:7] <- phylum
  } else if (tax.clean[i,4] == ""){
    class <- paste("Class_", tax.clean[i,3], sep = "")
    tax.clean[i, 4:7] <- class
  } else if (tax.clean[i,5] == ""){
    order <- paste("Order_", tax.clean[i,4], sep = "")
    tax.clean[i, 5:7] <- order
  } else if (tax.clean[i,6] == ""){
    family <- paste("Family_", tax.clean[i,5], sep = "")
    tax.clean[i, 6:7] <- family
  } else if (tax.clean[i,7] == ""){
    tax.clean$Species[i] <- paste("Genus_",tax.clean$Genus[i], sep = "_")
  }
}
tax_table(all) <- as.matrix(tax.clean)
all.clean <- subset_taxa(all,
  Kingdom != "Unassigned" &
  Kingdom != "Archaea" &
  Kingdom != "Eukaryota" &
  Family != "Mitochondria" &
  Order != "Chloroplast" &
  Genus != "Ralstonia"
) %>%
prune_taxa(taxa_sums(.) > 0, .) %>%
subset_samples(diet != "test") %>%
prune_taxa(taxa_sums(.) > 0, .) %>%
subset_samples(New_Diet != "1%_betamannan") %>%
prune_taxa(taxa_sums(.) > 0, .) %>%
subset_samples(sampleType != "feed") %>%
prune_taxa(taxa_sums(.) > 0, .)

sample_data(all.clean)$New_Diet <- ifelse(sample_data(all.clean)$New_Diet == "Control", "CTR", ifelse(sample_data(all.clean)$New_Diet == "4%_betamannan", "4%MN3", sample_data(all.clean)$New_Diet))
sample_data(all.clean)$New_Diet <- factor(sample_data(all.clean)$New_Diet, levels=c('CTR', '4%MN3'))

all.clean
tax_table(all.clean) <- tax_table(all.clean)[, c(1:7)]
sample_data(all.clean)$Group <- paste(sample_data(all.clean)$sampleType,sample_data(all.clean)$New_Diet,sep = "_")
psdata.p <- prune_taxa(taxa_sums(all.clean) >0, all.clean)
psdata.p
```

Rarefaction plot- This R code is using the "ggrare" function to create a rarefaction plot from the data in the "all.clean" object.
```{r fig2, fig.height = 4, fig.width = 12, fig.align = "center"}
annotation_colors <- list(
  #samplingTime = c(`T0`="gray" ,`T1` = "#FF7F00", `T2` = "#FFD92F", `T3`="#F781BF"),
  New_Diet = c(`CTR`="#e41a1cff", `4%MN3`="#984EA3"))


p <- ggrare(all.clean, step = 1000, 
            color = "New_Diet", 
            se = F,
            parallel = TRUE,
            plot = F) 
p + theme_bw() + 
  scale_fill_manual(values =annotation_colors$New_Diet) +
  scale_colour_manual( values = annotation_colors$New_Diet) 

```

Taxonomic classification- Phylum level taxonomic distribution. Bars report the mean abundance for each individual sample. 
```{r warning=FALSE, message=FALSE, fig.align='center'}

HG <- subset_samples(all.clean, sampleType == "Hindgut")
HG <- prune_taxa(taxa_sums(HG) > 0, HG)

PC <- subset_samples(all.clean, sampleType == "Pyloric_caeca")
PC <- prune_taxa(taxa_sums(PC) > 0, PC)


HG_T<- transform_sample_counts(HG, function(x) x / sum(x) )
HG.Final.RNA <- aggregate_rare(HG_T, level = "Phylum", detection = 1/100, prevalence = 10/100)
getPalette = colorRampPalette(brewer.pal(10, "Dark2")) 
PhylaPalette = getPalette(10)
cols  <- c(brewer.pal(8,"Set1"), brewer.pal(7,"Dark2"),brewer.pal(7,"Set2"),brewer.pal(12,"Set3"),brewer.pal(7,"Accent"),brewer.pal(12,"Paired"),"gray")

HG.Final.RNA_phylum_plot<- plot_composition(HG.Final.RNA, sample.sort = "Proteobacteria",otu.sort = "abundance", verbose = TRUE, group_by = "New_Diet")
HG.Final.RNA_phylum_plot <- HG.Final.RNA_phylum_plot + 
  theme_bw() + 
  #theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +
  scale_fill_manual(values = cols) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))

PC_T<- transform_sample_counts(PC, function(x) x / sum(x) )


PC.Final.RNA <- aggregate_rare(PC_T, level = "Phylum", detection = 1/100, prevalence = 10/100)
getPalette = colorRampPalette(brewer.pal(16, "Dark2")) 
PhylaPalette = getPalette(16)

cols  <- c(brewer.pal(8,"Set1"), brewer.pal(7,"Dark2"),brewer.pal(7,"Set2"),brewer.pal(12,"Set3"),brewer.pal(7,"Accent"),brewer.pal(12,"Paired"),"gray")


PC.Final.RNA_phylum_plot<- plot_composition(PC.Final.RNA, sample.sort = "Proteobacteria",otu.sort = "abundance", verbose = TRUE, group_by = "New_Diet")
PC.Final.RNA_phylum_plot <- PC.Final.RNA_phylum_plot + 
  theme_bw() + 
  #theme(axis.text.x=element_blank(), axis.ticks.x=element_blank()) +
  scale_fill_manual(values = cols) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


plot_grid(HG.Final.RNA_phylum_plot, PC.Final.RNA_phylum_plot, ncol = 1, align = "hv")

```

```{r, message=FALSE}
#Bacterial Community Composition for Manuscript
Final.seq.melt.RNA <- psmelt(tax_glom(all.clean, "Species"))
tax_ranks <- c("Phylum", "Class", "Order", "Family", "Genus", "Species")

for (rank in tax_ranks) {
  n_unique <- length(unique(Final.seq.melt.RNA[[rank]]))
  message(paste(rank, ": ", n_unique, sep = ""))
}
```

Alpha diversity- Alpha diversity is a measure of the diversity of species within a given area or sample. It can be measured in two different ways: Shannon diversity, which takes into account both the richness and evenness of species in a given sample, or observed richness, which simply counts the total number of species present. Shannon diversity is often used to compare the diversity of different samples, whereas observed richness can be used to compare the diversity of different areas.

```{r warning=FALSE, message=FALSE}
# Estimate richness of all.clean
shannon.div <- estimate_richness(all.clean, measures = c("Shannon", "Observed"))

# Get sample data
sampledata1<- data.frame(sample_data(all.clean))

# Rename row names
row.names(shannon.div) <- gsub("X","", row.names(shannon.div))
row.names(shannon.div) <- gsub("[.]","-", row.names(shannon.div))

# Merge data
sampleData <- merge(sampledata1, shannon.div, by = 0 , all = TRUE)

# Create Shannon Plot
plot11 <- ggboxplot(sampleData, x = "New_Diet", y = "Shannon",
          color = "black", palette = "jco", legend = "none", outlier.shape = NA)+ 
 # stat_compare_means(comparisons = my_comparisons)+ # Add pairwise comparisons p-value
  stat_compare_means(label.y = 4.3) +
  ggplot2::geom_jitter(
    mapping = aes_string(fill="New_Diet"),
    position = ggplot2::position_jitter(seed=123), 
    shape = 21,
    color = "black",
    size = 2,
    alpha = 0.8
  ) +
  theme_bw() +  labs(y= "Shannon index") +
  theme(legend.position="none",axis.title.x=element_blank()) +
  scale_fill_manual(values = c( "#E41A1C", "#984EA3")) + 
  scale_colour_manual( values = c( "#E41A1C", "#984EA3")) +
  facet_wrap(. ~ sampleType, ncol = 2) +       
  theme(panel.spacing = unit(1, "cm"))
```

Beta diversity- Beta diversity is a term used to refer to the differences in species composition between two different sites or habitats. It is often used to measure how different species are distributed across a landscape. The concept of beta diversity was first proposed by ecologist Robert H. Whittaker in 1960. The measure is used to quantify the variation in species composition between two different sites, such as an island and the mainland. The most commonly used measure for beta diversity is the Bray-Curtis index, which looks at the ratio of shared species between two sites. This index is used to measure the differences in species composition between areas and to identify the importance of certain areas in terms of species diversity.
```{r warning=FALSE, message=FALSE, fig.align='center'}
# Calculate PCoA on Bray distance
PCoA_bray_HG <- ordinate(physeq = HG, method = "PCoA", distance = "bray")

# Plot PCoA on Bray distance
PCoA_bray_HG_plot <- plot_ordination(
  physeq = HG, 
  ordination = PCoA_bray_HG, 
  color = "New_Diet"
) + 
  geom_point(shape = 19, alpha=0.7) + 
  theme_bw() + ggtitle("Hindgut: Microbiome") +
    theme(plot.title = element_text(hjust = 0.5))  + 
  xlab("PCoA 1 [47 %]") + ylab("PCoA 2 [9.3 %]") + 
  stat_ellipse() + scale_fill_manual(values = annotation_colors$New_Diet) + 
  scale_colour_manual( values = annotation_colors$New_Diet)+
  guides(color = guide_legend(title = "Diet")) 

# Calculate PCoA on Bray distance
PCoA_bray_PC <- ordinate(physeq = PC, method = "PCoA", distance = "bray")

# Plot PCoA on Bray distance
PCoA_bray_PC_plot <- plot_ordination(
  physeq = PC, 
  ordination = PCoA_bray_PC, 
  color = "New_Diet"
) + 
  geom_point(shape = 19, alpha=0.7) + 
  theme_bw() + ggtitle("Pyloric caeca: Microbiome") +
    theme(plot.title = element_text(hjust = 0.5)) + 
  xlab("PCoA 1 [29.2 %]") + ylab("PCoA 2 [15.4 %]") + 
  stat_ellipse() + scale_fill_manual(values = annotation_colors$New_Diet) + 
  scale_colour_manual( values = annotation_colors$New_Diet) +
  guides(color = guide_legend(title = "Diet")) 


# Grid plot of PCoA plots
up_row <- plot_grid(plot_2A, plot11, labels = c('B', 'C'), align = 'h', nrow = 1, rel_widths = c(0.5,1))
bottom_row <- plot_grid(PCoA_bray_HG_plot, PCoA_bray_PC_plot, labels = c('E', 'F'), align = 'h', ncol = 1)
```


```{r warning=FALSE, message=FALSE, fig.align='center'}
#Bacterial Community Composition for Manuscript
Final.seq.melt.RNA <- psmelt(tax_glom(HG, "Species"))
tax_ranks <- c("Phylum", "Class", "Order", "Family", "Genus", "Species")

for (rank in tax_ranks) {
  n_unique <- length(unique(Final.seq.melt.RNA[[rank]]))
  message(paste(rank, ": ", n_unique, sep = ""))
}

```



```{r warning=FALSE, message=FALSE, fig.align='center'}
#Bacterial Community Composition for Manuscript
Final.seq.melt.RNA.PC <- psmelt(tax_glom(PC, "Species"))
tax_ranks <- c("Phylum", "Class", "Order", "Family", "Genus", "Species")

for (rank in tax_ranks) {
  n_unique <- length(unique(Final.seq.melt.RNA.PC[[rank]]))
  message(paste(rank, ": ", n_unique, sep = ""))
}

```



```{r warning=FALSE, message=F, fig.align='center'}
library(doBy)
Final.seq.melt.RNA.PC <- psmelt(tax_glom(PC, "Species"))
table(grepl("Kingdom", unique(Final.seq.melt.RNA.PC$Phylum)))
table(grepl("Phylum", unique(Final.seq.melt.RNA.PC$Class)))
table(grepl("Class|Phylum", unique(Final.seq.melt.RNA.PC$Order)))
table(grepl("Order|Class|Phylum", unique(Final.seq.melt.RNA.PC$Family)))
table(grepl("Family|Order|Class|Phylum", unique(Final.seq.melt.RNA.PC$Genus)))
table(grepl("Family|Order|Class|Phylum|Genus", unique(Final.seq.melt.RNA.PC$Species)))

Phylum_df <- summaryBy(Abundance~Phylum, data=Final.seq.melt.RNA.PC, FUN=sum)
Phylum_df$Percent <- round(Phylum_df$Abundance.sum/sum(Phylum_df$Abundance.sum)*100, 4)
Phylum_df <- plyr::arrange(Phylum_df, plyr::desc(Percent))
Phylum_df$PercentageRound <- round(Phylum_df$Percent, digits = 2)
DT::datatable(Phylum_df)

class_df <- summaryBy(Abundance~Phylum+Class, data=Final.seq.melt.RNA.PC, FUN=sum)
class_df$Percent <- round(class_df$Abundance.sum/sum(class_df$Abundance.sum)*100, 4)
class_df <- plyr::arrange(class_df, plyr::desc(Percent))
class_df$Round <- round(class_df$Percent, digits = 2)
DT::datatable(class_df)

genus_df <- summaryBy(Abundance~Genus, data=Final.seq.melt.RNA.PC, FUN=sum)
genus_df$Percent <- round(genus_df$Abundance.sum/sum(genus_df$Abundance.sum)*100, 4)
genus_df <- plyr::arrange(genus_df, plyr::desc(Percent))
genus_df$Round <- round(genus_df$Percent, digits = 2)

DT::datatable(genus_df)

```


```{r warning=FALSE, message=F, fig.align='center'}
library(doBy)
Final.seq.melt.RNA.HG <- psmelt(tax_glom(HG, "Species"))
table(grepl("Kingdom", unique(Final.seq.melt.RNA.HG$Phylum)))
table(grepl("Phylum", unique(Final.seq.melt.RNA.HG$Class)))
table(grepl("Class|Phylum", unique(Final.seq.melt.RNA.HG$Order)))
table(grepl("Order|Class|Phylum", unique(Final.seq.melt.RNA.HG$Family)))
table(grepl("Family|Order|Class|Phylum", unique(Final.seq.melt.RNA.HG$Genus)))
table(grepl("Family|Order|Class|Phylum|Genus", unique(Final.seq.melt.RNA.HG$Species)))

Phylum_df <- summaryBy(Abundance~Phylum, data=Final.seq.melt.RNA.HG, FUN=sum)
Phylum_df$Percent <- round(Phylum_df$Abundance.sum/sum(Phylum_df$Abundance.sum)*100, 4)
Phylum_df <- plyr::arrange(Phylum_df, plyr::desc(Percent))
Phylum_df$PercentageRound <- round(Phylum_df$Percent, digits = 2)
DT::datatable(Phylum_df)

class_df <- summaryBy(Abundance~Phylum+Class, data=Final.seq.melt.RNA.HG, FUN=sum)
class_df$Percent <- round(class_df$Abundance.sum/sum(class_df$Abundance.sum)*100, 4)
class_df <- plyr::arrange(class_df, plyr::desc(Percent))
class_df$Round <- round(class_df$Percent, digits = 2)
DT::datatable(class_df)



genus_df <- summaryBy(Abundance~Genus, data=Final.seq.melt.RNA.HG, FUN=sum)
genus_df$Percent <- round(genus_df$Abundance.sum/sum(genus_df$Abundance.sum)*100, 4)
genus_df <- plyr::arrange(genus_df, plyr::desc(Percent))
genus_df$Round <- round(genus_df$Percent, digits = 2)

DT::datatable(genus_df)

```


```{r}
sampledf_HG <- data.frame(sample_data(HG))
bcdist_HG <- phyloseq::distance(HG, method="bray", normalized=TRUE)
adonis2(bcdist_HG ~ New_Diet, data = sampledf_HG, permutations = 9999)


sampledf_PC <- data.frame(sample_data(PC))
bcdist_PC <- phyloseq::distance(PC, method="bray",normalized=TRUE)
adonis2(bcdist_PC ~ New_Diet, data = sampledf_PC, permutations = 9999)
```

Hind gut and Pyloric caeca comparison based on control samples
```{r warning=FALSE, message=FALSE, fig.align='center'}
HG_PC <- subset_samples(all.clean, New_Diet != "4%MN3")
HG_PC <- prune_taxa(taxa_sums(HG_PC) > 0, HG_PC)



# Estimate richness of all.clean
shannon.div <- estimate_richness(HG_PC, measures = c("Shannon", "Observed","Simpson" ))

# Get sample data
sampledata1<- data.frame(sample_data(HG_PC))

# Rename row names
row.names(shannon.div) <- gsub("X","", row.names(shannon.div))
row.names(shannon.div) <- gsub("[.]","-", row.names(shannon.div))

# Merge data
sampleData <- merge(sampledata1, shannon.div, by = 0 , all = TRUE)

# Create Observed Richness Plot
q1 <- ggboxplot(sampleData, x = "sampleType", y = "Observed",
                color = "sampleType", palette = "jco", legend = "none") + 
  stat_compare_means(label.y = 260) +
  geom_jitter(aes(colour = sampleType), size = 2, alpha = 0.6) +
  geom_boxplot(aes(fill = sampleType), width=0.7, alpha = 0.5) +
  theme_bw() +  theme(legend.position="none",axis.title.x=element_blank()) +  
  scale_fill_manual(values = cols) + 
  scale_colour_manual( values = cols)



# Calculate PCoA on Bray distance
PCoA_bray_HG_PC <- ordinate(physeq = HG_PC, method = "PCoA", distance = "bray")

# Plot PCoA on Bray distance
PCoA_bray_HG_PC_plot <- plot_ordination(
  physeq = HG_PC, 
  ordination = PCoA_bray_HG_PC, 
  color = "sampleType"
) + 
  geom_point(shape = 19, alpha=0.7) + 
  theme_bw() + ggtitle("PCoA Plot - Bray") +
    theme(plot.title = element_text(hjust = 0.5))  + 
  xlab("PCoA 1 [46.7 %]") + ylab("PCoA 2 [15.7 %]") + 
  stat_ellipse() + scale_fill_manual(values = cols) + 
  scale_colour_manual( values = cols)

# Run adonis test
sampledf_PC <- data.frame(sample_data(HG_PC))
bcdist_PC <- phyloseq::distance(HG_PC, method="bray",normalized=TRUE)
result <- adonis2(bcdist_PC ~ sampleType, data = sampledf_PC, permutations = 9999)
PCoA_bray_HG_PC_plot <- PCoA_bray_HG_PC_plot + annotate(
  "text", x = 0.35, y = 0.3, 
  label = paste("Adonis R2 =", round(result$R2[1], 3),
                "\np-value =", result$`Pr(>F)`[1]),
  col = "black", fontface = "bold")

plot_grid(q1, PCoA_bray_HG_PC_plot, labels = c('A', 'B'), align = 'hv', ncol = 2, rel_widths = c(0.6, 1))
```



```{r warning=FALSE, message=FALSE, fig.align='center', echo=FALSE, eval=FALSE}
library(eulerr)
library(microbiome)
library(microbiomeutilities)

sample_data(all.clean)$Group <- paste(sample_data(all.clean)$sampleType,sample_data(all.clean)$New_Diet,sep = "_")
pseq.rel.f <- format_to_besthit(all.clean)

Group <- unique(as.character(meta(pseq.rel.f)$Group))

list_core <- c() # an empty object to store information

for (n in Group){ # for each variable n in DiseaseState
    #print(paste0("Identifying Core Taxa for ", n))
    
    ps.sub <- subset_samples(pseq.rel.f, Group == n) 
    
    core_m <- core_members(ps.sub,  
                           detection = 0.001,  
                           prevalence = 0.10)
    print(paste0("No. of core taxa in ", n, " : ", length(core_m))) # print core taxa identified in each DiseaseState.
    list_core[[n]] <- core_m # add to a list core taxa for each group.
    #print(list_core)
}


```

```{r warning=FALSE, message=FALSE, results='hide', fig.align='center', eval=FALSE, echo=FALSE}
plot(venn(list_core))
```

```{r, echo=FALSE }
#' Relative Abundance Plot
#'
#' For creating nice microbiome plots
#'
#' @param phylo_ob Phyloseq object with metadata in sample_data.
#' @param predictor Predictor of interest for statistics/plotting in sample_data.
#' @param type Taxonomic rank from tax_table, case insensitive; default is "genus".
#' @param relative_abun Use relative abundances, else absolute; default is TRUE.
#' @param id Define id variable for mixed models.
#' @param xlabs X-axis label
#' @param ylabs Y-axis label
#' @param main Title of plot
#' @param violin Use geom_violin for plotting, else boxplot; default is TRUE.
#' @param violin_scale Scale option for geom_violin; default is "width".
#' @param legend_title Legend title; default is name of predictor.
#' @param N_taxa Number of taxa to be plotted; default is 15.
#' @param By_median Order plot by median abundances, else mean abundances; default is TRUE.
#' @param no_other_type Taxa in lower abundances than top N_taxa, are grouped as "other", this will remove this group from the plot; default is FALSE.
#' @param legend_names Define variable names for legend text.
#' @param Time Time variable name for longitudinal datasets.
#' @param Timepoint Value in variable @Time to select.
#' @param Strata Name of variable for stratification;
#' @param Strata_val Value in variable @Strata to keep; default is 1.
#' @param no_legends Removes legend; default is FALSE.
#' @param no_names Removes taxa names; default is FALSE.
#' @param italic_names Taxa names will be in italic e.g. usable for family, genus, species levels; default is TRUE
#' @param Only_sig Only keep significant taxa; default is FALSE.
#' @param log Present plot on a log scale; default is TRUE.
#' @param log_max Maximum value of log-axis options:1, 10, 100; default is 100.
#' @param stat_out Outputs a data.frame with statistics to Global environment; default is FALSE.
#' @param p_val Displays p-values on plot; default is TRUE.
#' @param p_stars Shows stars instead of p-values; default is FALSE.
#' @param stats Select type of statistical test; options: "non-parametric", "parametric", "mixed", "mgs_feature"; default is "non-parametric".
#' @param p_adjust adjust p-values; default is "FALSE.
#' @param p_adjust_method options: "holm", "hochberg", "hommel", "bonferroni", "BH", "BY", "fdr"; default is "fdr".
#' @param p_adjust_full correction applied for all taxa in the dataset; default is FALSE.
#' @param colors define list of colors for plot. If not color brewer will be used; default is NULL.
#' @param color_by define taxonomic rank to color by; default is NULL.
#' @param order Order by abundance, else alphabetically; default is TRUE.
#' @param reverse Flip taxa order; default is FALSE.
#' @param list_taxa A list of specific taxa names to be analyzed; default is NULL.
#' @param select_taxa Choose all taxa from one or more taxonomic variables, eg. "Staphylococcus" or "Staph" or "coccus" or c("staph",bifido"); default is NULL.
#' @param select_type Taxonomic rank of the @select_taxa; default is "genus".
#' @param bar_chart Choose to make bar chart; default is FALSE.
#' @param bar_chart_stacked Produce stacked bar chart; default is FALSE
#' @param percent Print percentages on bar chart; default is FALSE.
#' @param facet_wrap Facet wrap chart by variable; eg. Time; default is NULL.
#' @param facet_label Facet wrap labels; default is NULL.
#' @param facet_n Show n for each facet; default is TRUE.
#' @param order_by Choose variable to order the selected taxa by; eg. Time; default is Time.
#' @param order_val Choose value for @order_by; default is NULL.
#' @param text_angle_x Choose value for rotation of axis-text; default is 0.
#'
#' @import ggplot2 phyloseq metagenomeSeq dplyr tidyr RColorBrewer lmerTest
#' @return A ggplot
#' @export

rabutable <- function(phylo_ob,
                     predictor="none",
                     type="genus",
                     relative_abun=TRUE,
                     id=NULL,
                     xlabs = "Relative abundance (%)",
                     ylabs = "Average relative abundance",
                     main = "Relative abundance plot",
                     violin=TRUE,
                     violin_scale = "width",
                     legend_title=predictor,
                     N_taxa=NULL,
                     By_median=TRUE,
                     no_other_type=FALSE,
                     legend_names=NULL,
                     Time="Time",
                     Timepoint=NULL,
                     Strata=NULL,
                     Strata_val="1",
                     no_legends = FALSE,
                     no_names=FALSE,
                     italic_names=TRUE,
                     Only_sig=FALSE,
                     log=TRUE,
                     log_max=100,
                     stat_out=FALSE,
                     p_val = TRUE,
                     p_stars=FALSE,
                     stats="non-parametric",
                     p_adjust=FALSE,
                     p_adjust_method="fdr",
                     p_adjust_full=FALSE,
                     colors=NULL,
                     color_by=NULL,
                     order=TRUE,
                     reverse=FALSE,
                     list_taxa=NULL,
                     select_taxa=NULL,
                     select_type="genus",
                     bar_chart=FALSE,
                     bar_chart_stacked=FALSE,
                     facet_wrap=NULL,
                     facet_label=NULL,
                     facet_n=TRUE,
                     percent=FALSE,
                     order_by="Time",
                     order_val=NULL,
                     text_angle_x=0)
{
  if(!is.null(list_taxa) & is.null(N_taxa)) N_taxa = length(list_taxa)
  if(is.null(N_taxa) & is.null(list_taxa)) N_taxa=15
  options(dplyr.summarise.inform = FALSE)
  if(bar_chart_stacked==TRUE) {
    bar_chart=TRUE
    p_val=FALSE
  }
  if(predictor=="none") {
    sample_data(phylo_ob)$none <- "All samples"
    p_val=FALSE
    if(bar_chart_stacked==FALSE & is.null(color_by)) no_legends = TRUE
  }
  phylo_ob <- prune_samples(sample_sums(phylo_ob)>0,phylo_ob) #removes empty samples;
  otu_mat <- as(otu_table(phylo_ob), "matrix")
  if(taxa_are_rows(phylo_ob)) otu_mat <- t(otu_mat)
  if(!is.null(facet_wrap)) index <- !is.na(get_variable(phylo_ob, predictor)) & !is.na(get_variable(phylo_ob, facet_wrap))
  else   index <- !is.na(get_variable(phylo_ob, predictor))
  if(length(unique(index)) !=1) message(paste(length(which(index==F)), "samples have been removed from full dataset (predictor/facet_wrap NAs)"))
  otu_mat <- otu_mat[index,]
  otu_mat  <- otu_mat[,colSums(otu_mat)>0] #removes empty OTUs;
  OTU_index <- colnames(otu_mat)
  tax <- as(tax_table(phylo_ob), "matrix") %>% data.frame(stringsAsFactors=FALSE)
  tax <- tax[rownames(tax) %in% OTU_index,]
  tax[is.na(tax)] <- "unclassified"
  tax[tax==""] <- "unclassified"
  names(tax) <- tolower(names(tax))
  type <- tolower(type)
  if(!is.null(select_type)) select_type <- tolower(select_type)
  tax$OTU <- rownames(tax)
  samp <- data.frame(sample_data(phylo_ob), stringsAsFactors=TRUE)
  samp <- samp[index,]
  if(is.null(facet_wrap)) samp$wrap <- ""
  if(!is.null(facet_wrap)) samp$wrap <- samp[,facet_wrap]
  if(!is.null(Timepoint)){
    index <- rownames(samp[(samp[,Time] ==Timepoint),])
    otu_mat <- otu_mat[rownames(otu_mat) %in% index,]
    otu_mat  <- otu_mat[,colSums(otu_mat)>0] #removes empty OTUs;
    OTU_index <- colnames(otu_mat)
    tax <- tax[rownames(tax) %in% OTU_index,]
    samp <- samp[rownames(samp) %in% index,]
  }
  
  list <-as.character(tax[,type])
  unique_tax <- unique(list)
  
  abund <- as.data.frame(matrix(rep(0,(length(unique_tax)*nrow(otu_mat))),ncol=length(unique_tax)))
  row.names(abund) <- row.names(otu_mat)
  names(abund) <- unique_tax
  for(i in names(abund)){
    if(is.array(otu_mat[,list==i]))  abund[,i] <- rowSums(otu_mat[,list== i])
    else   abund[,i] <- otu_mat[,list== i]
  }
  abund_org <- abund
  if(relative_abun==TRUE) abund <- apply(abund,1,function(x) x/sum(x)) %>% t %>% as.data.frame()
  abund_all <- abund
  if (is.null(list_taxa) & !is.null(select_taxa)) {
    list_taxa <- NULL
    for(i in 1:length(select_taxa)){
      list_taxa <- c(list_taxa,(as.character(unique(tax[grep(select_taxa[[i]],tax[,select_type],ignore.case=TRUE),type]))))
    }
  }
  if (!is.null(list_taxa)) {
    if (is.null(N_taxa)) N_taxa <- length(list_taxa)
    abund <- abund[,colnames(abund) %in% list_taxa, drop = FALSE]
    unique_tax <- names(abund)
  }
  
  if(length(abund)>1){
    index <- !is.na(rownames(samp))
    if (!is.null(order_val))  index <- samp[,order_by] ==order_val
    abund <- abund[,order(-colSums(abund[index,]))]
    if (By_median)  abund <- abund[,order(-apply(abund[index,], 2, median))]
    if("unclassified" %in% unique_tax) abund <- abund[c(setdiff(names(abund), "unclassified"),"unclassified")] #Move unclassified to end
    if(N_taxa<length(unique_tax)) abund <- abund[-(length(unique_tax)-(length(unique_tax)-N_taxa)+1):-length(unique_tax)]
    if(no_other_type==FALSE) abund[, paste("Other",type)] <- rowSums(abund_all[,!names(abund_all) %in% names(abund)])
  }
  index <- !is.na(rownames(samp))
  if(!is.null(Strata)) index <- samp[,Strata]==Strata_val
  samp2 <- samp %>% filter(index)
  if(p_val==TRUE & (bar_chart==FALSE | (bar_chart==TRUE & bar_chart_stacked==FALSE))){
    if(p_adjust_full ==TRUE | stats=="mgs_feature"){
      abund2 <- abund_org %>% filter(index)
      if(relative_abun==TRUE & stats!="mgs_feature") abund2 <- apply(abund2,1,function(x) x/sum(x)) %>% t %>% as.data.frame()
    }
    else abund2 <- abund %>% filter(index)
    if(stats=="mgs_feature" & length(levels(factor(samp2[,predictor])))>2){
      stats="non-parametric"
      message("MGS not available for >2 predictors, switching to non-parametric")
    }
    if(stats=="mixed" & is.null(id)){
      stats="non-parametric"
      message("No id variable for mixed model, switching to non-parametric")
    }
    if(stats=="mixed"){
      message("Mixed model statistics")
      pred <- samp2[,predictor]
      id <- samp2[,id]
      if(!is.null(facet_wrap)) {
        message(paste0("Using ",facet_wrap," as mixed model group variable"))
        facet <- samp2[,"wrap"]
        pval <- cbind(abund2,pred,id,facet) %>% as_tibble() %>%
          gather(variable, value,-"pred",-"id",-"facet") %>%
          group_by(variable) %>%
          summarize(pval = lmerTest::lmer(value ~ pred + factor(facet) + (1 | id)) %>% anova %>% filter(row_number()==1) %>% .$'Pr(>F)', .groups = 'drop')
      }
      else {
        message(paste0("No group variable defined for mixed model in facet_wrap"))
        pval <- cbind(abund2,pred,id) %>% as_tibble() %>%
          gather(variable, value,-"pred",-"id") %>%
          group_by(variable) %>%
          summarize(pval = lmerTest::lmer(value ~ pred + (1 | id)) %>% anova %>% .$'Pr(>F)', .groups = 'drop')
      }
      pval <- pval %>%  mutate(wrap="Mixed",p_adjust=p.adjust(pval, p_adjust_method))
      pval$wrap <- factor(pval$wrap,levels=c(levels(factor(samp2[,facet_wrap])),"Mixed"))
    }
    else {
      pval <- data.frame()
      for (i in 1:length(unique(samp2$wrap))){
        index <- samp2$wrap==unique(samp2$wrap)[[i]]
        abund3 <- abund2 %>% filter(index)
        pred <- samp2[index,predictor]
        # test with featureModel
        if(stats=="mgs_feature"){
          mgs <- metagenomeSeq::newMRexperiment(counts = t(abund3))
          mgsp <- metagenomeSeq::cumNormStat(mgs)
          mgs <- metagenomeSeq::cumNorm(mgs, mgsp)
          mod <- model.matrix(~as.numeric(pred == unique(pred)[1]))
          if(length(unique(samp2$wrap))>1) message(paste0("MGS FeatureModel for facet_wrap = ",unique(samp2$wrap)[[i]]))
          else message("MGS FeatureModel")
          mgsfit <- metagenomeSeq::fitFeatureModel(obj=mgs,mod=mod)
          pval_tmp <- data.frame(variable=mgsfit$taxa,pval=mgsfit$pvalues)
        }
        if(stats=="non-parametric"){   #Kruskal-Wallis
          if(i==1) message("Non-parametric statistics")
          pval_tmp <- cbind(abund3,pred) %>% as_tibble() %>%
            gather(variable, value,-"pred") %>%
            group_by(variable) %>%
            summarize(pval = kruskal.test(value ~ pred)$p.value, .groups = 'drop')
        }
        if(stats=="parametric"){
          if(i==1) message("Parametric statistics")
          pval_tmp <- cbind(abund3,pred) %>% as_tibble() %>%
            gather(variable, value,-"pred") %>%
            group_by(variable) %>%
            summarize(pval = oneway.test(value ~ pred)$p.value, .groups = 'drop')
        }
        pval_tmp <- pval_tmp %>%
          mutate(wrap=unique(samp2$wrap)[[i]],p_adjust=p.adjust(pval, p_adjust_method))
        pval <- rbind(pval,pval_tmp)
      }
    }
    if(p_adjust) message(paste(p_adjust_method,"correction applied for",length(unique(pval$variable)),"taxa"))
  }
  
  bacteria <- rev(names(abund))
  subset <- cbind(samp[!names(samp) %in% bacteria], abund) #fjerner evt eksisterende navne fra dataset og merger;
  subset$predictor2 <-  as.factor(subset[,predictor])
  subset$ID <- rownames(subset)
  if(!is.null(Strata)) subset[,Strata] <- as.factor(subset[,Strata])
  if(!is.null(facet_wrap)){
    subset$wrap <-  as.factor(subset[,facet_wrap])
    if(!is.null(Strata))
      molten <- subset[,c("ID",paste(bacteria),"predictor2",Strata,"wrap")] %>% gather(variable, value,-"predictor2",-"ID",-all_of(Strata),-"wrap")
    else
      molten <- subset[,c("ID",paste(bacteria),"predictor2","wrap")] %>% gather(variable, value,-"predictor2",-"ID",-"wrap")
  }
  if(is.null(facet_wrap)){
    if(!is.null(Strata))
      molten <- subset[,c("ID",paste(bacteria),"predictor2",Strata)] %>% gather(variable, value,-"predictor2",-"ID",-all_of(Strata))
    else
      molten <- subset[,c("ID",paste(bacteria),"predictor2")] %>% gather(variable, value,-"predictor2",-"ID")
  }
  if(!is.null(color_by)){
    molten[molten$variable != paste("Other",type),"colvar"] <- molten %>% dplyr::filter(variable != paste("Other",type)) %>% .[,"variable"] %>% match(tax[,type]) %>% tax[.,color_by] %>% as.character
    molten[molten$variable == paste("Other",type),"colvar"] <- paste("Other",color_by) %>% as.character
  }
  
  molten$variable <- gsub('_',' ',molten$variable)
  
  if(order)   ordered <- unique(molten$variable) #level order
  if(!order)   ordered <-sort(unique(molten$variable))#level order alphabetically
  
  molten$variable <- factor(molten$variable, levels=ordered)
  if(is.null(color_by))  molten$colvar <- molten$variable
  if(!is.null(Strata))  molten <- molten[which(molten[,Strata]==Strata_val), ]
  
  if(is.null(colors)){
    cols  <- c(brewer.pal(8,"Set1"), brewer.pal(7,"Dark2"),brewer.pal(7,"Set2"),brewer.pal(12,"Set3"),brewer.pal(7,"Accent"),brewer.pal(12,"Paired"),"gray")
    cols <- cols[1:length(levels(factor(molten$predictor2)))]
  }
  if(!is.null(colors)) cols <- colors
  
  if(bar_chart==TRUE & bar_chart_stacked==FALSE & is.null(legend_names))  legend_names <- as.character(levels(factor(molten$predictor2)))
  if(is.null(legend_names))  legend_names <- as.character(levels(factor(molten$predictor2)))
  ordered2<- rev(unique(molten$colvar))
  if(reverse){
    if(bar_chart==FALSE) {
      molten$predictor2 <- factor(molten$predictor2, levels=rev(levels(molten$predictor2)))#manual faceting for levels;
      legend_names <- rev(legend_names)
      cols <- rev(cols)
    }
    if(bar_chart==TRUE) {
      molten$colvar <- factor(molten$colvar, levels=rev(levels(factor(molten$colvar))))#manual faceting for levels;
      molten$variable <- factor(molten$variable, levels=rev(levels(factor(molten$variable))))
      cols <- rev(cols)
      ordered2<- rev(ordered2)
    }
  }
  
  if(bar_chart){
    log=FALSE
    cols  <- c(brewer.pal(8,"Set1"), brewer.pal(7,"Dark2"),brewer.pal(7,"Set2"),brewer.pal(12,"Set3"),brewer.pal(7,"Accent"),brewer.pal(12,"Paired"),"gray")
    #  ordered <- levels(factor(molten$colvar))
    if(is.null(color_by) & bar_chart_stacked==FALSE)   cols <- cols[1:length(levels(factor(molten$predictor2)))]
    
    else cols <- cols[c(1:length(levels(factor(molten$colvar)))-1,length(cols))]
    if(!is.null(colors)) cols <- colors
    if(is.null(color_by) & reverse==FALSE) cols <- rev(cols)
    if(!is.null(color_by) & reverse==TRUE) cols <- rev(cols)
    if(is.null(facet_wrap))  molten$wrap <- ""
    molten_mean <- molten %>%
      dplyr::group_by(variable,predictor2,wrap,colvar) %>%
      dplyr::summarize(value = mean(value))
    molten_mean$colvar <- factor(molten_mean$colvar, levels=ordered2)
  }
  #Calculate pvalue for outcomes
  if(p_val==TRUE & ((bar_chart==TRUE & bar_chart_stacked==FALSE) | bar_chart==FALSE) & is.null(color_by)){
    if(is.null(facet_wrap)) molten$wrap <- ""
    if(!is.null(facet_wrap)) {
      pval <- data.frame(pval=pval[gsub('_',' ',pval$variable) %in% ordered,]$pval,p_adjust=pval[gsub('_',' ',pval$variable) %in% ordered,]$p_adjust, variable=gsub('_',' ',pval[gsub('_',' ',pval$variable) %in% ordered,]$variable),wrap=pval[gsub('_',' ',pval$variable) %in% ordered,]$wrap)
    }
    else {
      pval <- data.frame(pval=pval[gsub('_',' ',pval$variable) %in% ordered,]$pval,p_adjust=pval[gsub('_',' ',pval$variable) %in% ordered,]$p_adjust, variable=gsub('_',' ',pval[gsub('_',' ',pval$variable) %in% ordered,]$variable))
      if(length(pval$variable)-length(ordered)<0) pval <- pval[match(pval$variable,ordered[length(pval$variable)-length(ordered)]),]
    }
    pval$predictor2 <- molten$predictor2[1]
    pval$pval <- ifelse(is.na(pval$pval),1,pval$pval)
    pval$p_adjust <- ifelse(is.na(pval$p_adjust),1,pval$p_adjust)
    if(Only_sig){
      index <- pval[pval$pval<0.05,"variable"]
      molten <- molten[molten$variable %in% index,]
      pval <- pval[pval$pval<0.05,]
    }
    
    if(stat_out){
      median_iqr <<- molten %>% dplyr::group_by(variable, predictor2) %>% dplyr::summarize( N = length(value),median = median(value)*100,Q1=quantile(value, 1/4)*100,Q3=quantile(value, 3/4)*100, IQR = IQR(value)) %>% as.data.frame
      pval_out <<- pval
      mean_sd <<- molten %>% dplyr::group_by(variable, predictor2) %>% dplyr::summarize( N = length(value),mean = mean(value)*100,sd=sd(value)*100) %>% as.data.frame
    }
  }
  if(bar_chart==FALSE){
    if(ncol(tax)>=6) molten$value <- molten$value+1e-6 #add pseudocount for log scale 0;
    else   molten$value <- molten$value+0.001 #add pseudocount for log scale 0;
    ordered <- levels(factor(molten$colvar))
    p <- ggplot(molten, aes(x=variable, y=value, fill=predictor2)) +
      {if(violin){geom_violin(scale = violin_scale,width = 0.65, position=position_dodge(width=0.9),size=1, color="#00000000")} else {geom_boxplot(width = 0.55, position=position_dodge(width=0.8),size=0.3,outlier.size = 0,outlier.color = "grey")}}+
      {if(violin){stat_summary(fun=median, fun.min = min, fun.max = max, geom="point", size=0.8, color="black", position=position_dodge(width=0.9))} else {stat_summary(fun=median, fun.min = min, fun.max = max, geom="point", size=0.8, color="#00000000", position=position_dodge(width=0.9))}}+ theme_bw() + theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),legend.key = element_blank(),legend.text=element_text(size=12),legend.key.size = unit(0.5, "cm"))+ coord_flip() +xlab(NULL)+ylab(xlabs)+ggtitle(main)
    if(length(unique(molten$variable))>1) p <- p+ geom_vline(xintercept=seq(1.5, length(unique(molten$variable))-0.5, 1),lwd=0.2, colour="grey")
    
    p <- p +  scale_fill_manual(values =cols,labels=legend_names) + guides(fill = guide_legend(title=legend_title, reverse = TRUE,override.aes = list(linetype=0, shape=16,color=rev(cols),size=5, bg="white")))
    
  }
  
  # legend_names <- molten_mean[molten_mean$variable %in% rev(molten_mean$colvar)[1],] %>% arrange(desc(value)) %>% ungroup %>% pull(predictor2) #order by highest abundant taxa
  if(bar_chart==TRUE){
    if(bar_chart_stacked==TRUE)
      p <-  ggplot(molten_mean,aes(x=factor(predictor2,levels=legend_names,labels=legend_names),y=value, fill=variable)) + theme_bw()+geom_bar(stat="identity")+ theme_bw() + theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),legend.key = element_blank(),axis.title=element_text(size=14),legend.text=element_text(size=12), axis.text = element_text(size = 12),strip.text = element_text(size = 12),legend.key.size = unit(0.5, "cm"),text=element_text(size=12)) +xlab(NULL)+ylab(ylabs)+ggtitle(main) +  scale_fill_manual(values =cols,labels=ordered) + guides(fill = guide_legend(title=NULL))
    if(bar_chart_stacked==FALSE){
      if(!is.null(color_by)) p <-   ggplot(molten_mean,aes(x=variable,y=value, fill=colvar,group=wrap))+geom_bar(stat="identity", position = position_dodge(width = 0.95))+ scale_fill_manual(values =cols,labels=ordered2)+ guides(fill = guide_legend(title=color_by))
      else {
        p <-   ggplot(molten_mean,aes(x=variable,y=value, fill=predictor2))+geom_bar(stat="identity", position = position_dodge(width = 0.95))+ scale_fill_manual(values =cols,labels=legend_names)+ guides(fill = guide_legend(title=legend_title))
      }
      if(length(unique(molten_mean$variable))>1) p <- p+ geom_vline(xintercept=seq(1.5, length(unique(molten_mean$variable))-0.5, 1),lwd=0.2, colour="grey")
      p <-  p+ theme_bw()  + theme(panel.grid.major = element_blank(),panel.grid.minor = element_blank(),legend.key = element_blank(),axis.title=element_text(size=14),legend.text=element_text(size=12), axis.text = element_text(size = 12),strip.text = element_text(size = 12),legend.key.size = unit(0.5, "cm"),text=element_text(size=12)) +xlab(NULL)+ylab(ylabs)+ggtitle(main)+ theme(strip.background = element_blank()) +coord_flip()
    }
  }
  if(!is.null(facet_wrap))   {
    if(is.null(facet_label)) label_names <- levels(factor(samp[,facet_wrap]))
    if(!is.null(facet_label)) label_names <- facet_label
    if(facet_n==TRUE){
      label_names <- samp2 %>%
        dplyr::group_by(get(facet_wrap)) %>%
        dplyr::summarise(n = n()) %>%
        dplyr::mutate(pasted_label = paste0(levels(factor(samp2[,facet_wrap])), ", n = ", n))
      label_names <- as.character(label_names$pasted_label)
    }
    names(label_names) <- levels(factor(samp2[,facet_wrap]))
    if(stats=="mixed") {
      label_names <- c(label_names,"Mixed")
      names(label_names) <- c(levels(factor(samp2[,facet_wrap])),"Mixed")
    }
    p <- p+ facet_grid(~wrap,labeller = labeller(wrap=label_names),scales = "free", space = "free")+  theme(strip.background = element_blank())
    if(bar_chart==FALSE) p$layers[4:5] <- NULL
  }
  if(italic_names==TRUE &  (bar_chart==FALSE | (bar_chart==TRUE & bar_chart_stacked==FALSE)))   p <- p+ theme(axis.text.y=element_text(face = "italic"))
  if(!is.null(color_by)) {
    # p <- p + facet_grid(~predictor2, scales = "free", space = "free")
    if(color_by=="genus" | color_by=="family" | color_by=="species") p <- p+ theme(legend.text=element_text(face = "italic"))
    if(color_by==type & bar_chart_stacked==FALSE ) p <- p+theme(legend.position="none")
  }
  
  if(p_val==TRUE){
    if(log==FALSE){
      if(bar_chart==TRUE) pval$y <- max(molten_mean$value)*1.10
      else pval$y <- max(molten$value)*1.15
    }
    else pval$y <-ifelse(log_max==100,10,ifelse(log_max==10,0.126,0.0126))
    if(p_adjust==TRUE){
      if(log==FALSE & bar_chart==FALSE) pval$y_adjust <- 1.22
      if(log==FALSE & bar_chart==TRUE) pval$y_adjust <- max(molten_mean$value)*1.25
      if(log==TRUE) pval$y_adjust <- ifelse(log_max==100,105,ifelse(log_max==10,1.26,0.126))
    }
  }
  if(log==TRUE){
    if(p_val==FALSE){
      if(log_max == 100)  p <- p+ scale_y_log10(breaks=c(.000001,.001,.01,.1,1),labels=c("0%","0.1%","1%","10%","100%"))
      if(log_max == 10)  p <- p+ scale_y_log10(limits=c(0.001,0.13),breaks=c(.001,.01,.05,.1),labels=c("0%","1%","5%","10%"))
      if(log_max == 1)  p <- p+ scale_y_log10(limits=c(0.001,0.013),breaks=c(.001,.01),labels=c("0%","1%"))
    }
    if(p_val==TRUE){
      if(p_adjust){
        if(log_max == 100)  p <- p+ scale_y_log10(breaks=c(.000001,.001,.01,.1,1,7,70),labels=c("0%","0.1%","1%","10%","100%", "P-value", "q-value"))
        if(log_max == 10)  p <- p+ scale_y_log10(breaks=c(.001,.01,.05,0.1,0.126,1.26),labels=c("0%","1%","5%","10%", "P-value", "q-value"))
        if(log_max == 1)  p <- p+ scale_y_log10(breaks=c(.001,.01,0.0126,0.126),labels=c("0%","1%", "P-value", "q-value"))
      }
      else{
        if(log_max == 100)  p <- p+ scale_y_log10(breaks=c(.000001,.001,.01,.1,1,7),labels=c("0%","0.1%","1%","10%","100%", "P-value"))
        if(log_max == 10)  p <- p+ scale_y_log10(breaks=c(.001,.01,.05,0.10,0.126),labels=c("0%","1%","5%","10%", "P-value"))
        if(log_max == 1)  p <- p+ scale_y_log10(breaks=c(.001,.01,0.0126),labels=c("0%","1%", "P-value"))
      }
    }
  }
  if(log==FALSE){
    if(p_val==FALSE) p <- p + scale_y_continuous(breaks=c(0,.25,.50,.75,1),labels=c("0%","25%","50%","75%","100%"))
    if(p_val==TRUE){
      if(p_adjust==TRUE) {
        if(max(molten_mean$value)<=1 & max(molten_mean$value)>=0.75) p <- p + scale_y_continuous(breaks=c(0,.25,.50,.75,1,max(molten_mean$value)*1.07,max(molten_mean$value)*1.25),labels=c("0%","25%","50%","75%","100%", "P-value", "q-value"))
        if(max(molten_mean$value)<0.75 & max(molten_mean$value)>=0.50) p <- p + scale_y_continuous(breaks=c(0,.25,.50,max(molten_mean$value)*1.07,max(molten_mean$value)*1.25),labels=c("0%","25%","50%", "P-value", "q-value"))
        if(max(molten_mean$value)<0.50 & max(molten_mean$value)>=0.25) p <- p + scale_y_continuous(breaks=c(0,.1,.2,.3,.4,max(molten_mean$value)*1.07,max(molten_mean$value)*1.25),labels=c("0%","10%","20%","30%","40%", "P-value", "q-value"))
        if(max(molten_mean$value)<0.25) p <- p + scale_y_continuous(breaks=c(0,.05,.1,.15,.2,max(molten_mean$value)*1.07,max(molten_mean$value)*1.25),labels=c("0%","5%","10%","15%","20%", "P-value", "q-value"))
      }
      if(p_adjust==FALSE) {
        if(max(molten_mean$value)<=1 & max(molten_mean$value)>=0.75)  p <- p + scale_y_continuous(breaks=c(0,.25,.50,.75,1,max(molten_mean$value)*1.07),labels=c("0%","25%","50%","75%","100%", "P-value"))
        if(max(molten_mean$value)<0.75 & max(molten_mean$value)>=0.50) p <- p + scale_y_continuous(breaks=c(0,.25,.50,max(molten_mean$value)*1.07),labels=c("0%","25%","50%", "P-value"))
        if(max(molten_mean$value)<0.50 & max(molten_mean$value)>=0.25) p <- p + scale_y_continuous(breaks=c(0,.1,.2,.3,.4,max(molten_mean$value)*1.07),labels=c("0%","10%","20%","30%","40%", "P-value"))
        if(max(molten_mean$value)<0.25) p <- p + scale_y_continuous(breaks=c(0,.05,.1,.15,.2,max(molten_mean$value)*1.07),labels=c("0%","5%","10%","15%","20%", "P-value"))
      }
    }
  }
  
  p <-  p + theme(plot.background = element_blank(),panel.background = element_blank(),plot.title = element_text(hjust = 0.5))
  p <-  p + theme(axis.text.x = element_text(angle = text_angle_x, vjust = ifelse(text_angle_x<0 & text_angle_x>-90 , 0, ifelse(text_angle_x>=0 & text_angle_x<90, 1, 0.5)), hjust=ifelse(text_angle_x==0 | text_angle_x==180 | text_angle_x==-180 | text_angle_x==180, 0.5, ifelse((text_angle_x<0 & text_angle_x>=-90) | text_angle_x>=270, 0, 1))))
  if (bar_chart==TRUE & bar_chart_stacked==FALSE & percent==TRUE)  p <- p+  geom_text(aes(label = paste0(sprintf("%.2f",value*100), "%")), hjust = -.12, position=position_dodge(width=0.95))+scale_y_continuous(limits=c(0,max(molten_mean$value)+0.2),labels = scales::percent)
  if(no_legends) p <- p + theme(legend.position="none")
  if(no_names)  p <- p + theme(axis.text.y=element_blank(),axis.ticks.y=element_blank())
  stars.pval <- function (p.value)
  {    unclass(symnum(p.value, corr = FALSE, na = FALSE, cutpoints = c(0, 0.001, 0.01, 0.05, 1), symbols = c("***", "**",  "*", "NS")))
  }
  if(p_stars==TRUE & p_val==TRUE) p <- p + geom_text(data=pval,aes(x=variable,y=y,label=paste(stars.pval(pval))) ,size=3,hjust=1)
  
  if(p_stars==FALSE & p_val==TRUE & (bar_chart==FALSE | (bar_chart==TRUE & bar_chart_stacked==FALSE))){
    p <- p + geom_text(data=pval,aes(x=variable,y=y,label=ifelse(pval<0.05, paste(format.pval(pval,1,0.001,nsmall=3)),"")) ,size=3,hjust=1,fontface="bold")
    p <- p + geom_text(data=pval,aes(x=variable,y=y,label=ifelse(pval>=0.05, paste(format.pval(pval,1,0.001,nsmall=3)),"")) ,size=3,hjust=1)
    if(p_adjust){
      p <- p + geom_text(data=pval,aes(x=variable,y=y_adjust,label=ifelse(p_adjust<0.05, paste(format.pval(p_adjust,1,0.001,nsmall=3)),"")) ,size=3,hjust=1,fontface="bold")
      p <- p + geom_text(data=pval,aes(x=variable,y=y_adjust,label=ifelse(p_adjust>=0.05, paste(format.pval(p_adjust,1,0.001,nsmall=3)),"")) ,size=3,hjust=1)
    }
    if(stats=="mixed" & !is.null(facet_wrap)){
      if(bar_chart==FALSE) p <- p + expand_limits(y = 2)
      if(bar_chart==TRUE) p <- p + expand_limits(y = max(molten_mean2$value))
    }
  }
  return(molten)
}
```


```{r, fig.align='center'}
library(tidyverse) 
library(pheatmap) 

df1 <- rabutable(phylo_ob = all.clean, predictor= "New_Diet", type = "Genus", facet_wrap   ="sampleType", N_taxa = 20)

data = df1 %>%   
  mutate(ID = paste0(variable, ":", wrap, "_", predictor2)) %>%  
  group_by(ID) %>%   
  summarize(meanvalue = mean(log(value))) %>%   
  mutate(feedtime = sub('.*:', '', ID)) %>%  
  mutate(ID = sub(':.*', '', ID)) %>%   
  pivot_wider(names_from = feedtime, values_from = meanvalue)    

rabuplot_df_genus <- as.data.frame(data)
rownames(rabuplot_df_genus) <- data$ID 
rabuplot_df_genus <- rabuplot_df_genus[,-1] 

heatmap_colors <- colorRampPalette(c("#18b29f","#FFFFFF","#ac6721"), interpolate = "spline", space = "rgb")(51)
annotation_col <- 
  colnames(rabuplot_df_genus) %>% 
  as.data.frame() %>% 
  dplyr::rename(common = ".") %>% 
  tidyr::separate(col = common,  into = c("Time", "Diet"), remove = F, extra = "drop") %>% # If replicates are present, we drop them here
  dplyr::select(common,Time, Diet) %>%  
  tibble::column_to_rownames(var = "common")
colnames(annotation_col) <- c("Type" , "Diet")

annotation_col$Diet[1] <- "4%MN3"
annotation_col$Diet[3] <- "4%MN3"
annotation_col$Diet[4] <- "CTR"

annotation_col$Type[1] <- "Hindgut"
annotation_col$Type[2] <- "Hindgut"

annotation_col$Type[3] <- "Pyloric caeca"
annotation_col$Type[4] <- "Pyloric caeca"



annotation_colors <- list(
  Diet = c(`CTR` = "#e41a1cff", `4%MN3` = "#984ea3ff"),
    Type = c(`Hindgut` = "darkorange", `Pyloric caeca` = "darkblue"))



row.names(rabuplot_df_genus)[2] <- "BCP group"   
differential_heatmap_plot <- pheatmap(t(rabuplot_df_genus), 
         annotation_row = annotation_col,
         annotation_colors = annotation_colors,  
        color = heatmap_colors,
         scale = "row", 
         cluster_rows = F, 
         cluster_cols = T, 
         gaps_row = c(2),
         show_colnames = T,
        show_rownames = F)

```

# Transcriptomics
```{r}
# Replace this base URL with the raw content URL of your GitHub repository
base_url <- "https://raw.githubusercontent.com/shashank-KU/ImprovaFish-MDF-Effects/main/"

# Specify the paths to your files on GitHub
host_gut_rawCounts_url <- paste0(base_url, "Transcriptomics/high_dosage_trial/output.txt")
sample_info_url <- paste0(base_url, "Transcriptomics/high_dosage_trial/sample_info.txt")

# Read the files
omics_data_host <- read.table(url(host_gut_rawCounts_url),  header = T, row.names = 1)
sample_info <- read.table(url(sample_info_url),  header = T, row.names = 1)

colnames(omics_data_host) <- sub("\\..*", "", colnames(omics_data_host))

r1 <- row.names(sample_info)
omics_data_host <- omics_data_host[, r1]
#all(colnames(omics_data_host) == rownames(sample_info))

# Hindgut
sample_info_hindgut <- sample_info[sample_info$sampleType == "hindgut", ]
matching_cols <- intersect(colnames(omics_data_host), rownames(sample_info_hindgut))
omics_data_host_gut <- omics_data_host[, matching_cols]

df <- round(omics_data_host_gut) %>%
  # The next steps require a data frame and round() returns a matrix
  as.data.frame() %>%
  # Only keep rows that have total counts above the cutoff
  dplyr::filter(rowSums(.) >= 0)

all(colnames(df) == rownames(sample_info_hindgut))

dds_gut <- DESeqDataSetFromMatrix(
  countData = df, # Our prepped data frame with counts
  colData = sample_info_hindgut, # Data frame with annotation for our samples
  design = ~New_Diet # Here we are not specifying a model
)

# dds_gut$group <- factor(paste0(dds_gut$New_Diet))
# design(dds_gut) <- ~ group-1

dds_gut <- DESeq(dds_gut, parallel = T)
#resultsNames(dds_gut)
res <- results(dds_gut)
res <- res[order(res$padj),]
table(res$padj < 0.05)
res_tbl <- as_tibble(res, rownames = "ENSEMBL") %>%
  filter(padj <0.05)%>%
  arrange(padj)

vsdata <- vst(dds_gut)
pcaPlot <- DESeq2::plotPCA(vsdata, intgroup = c("New_Diet"), ntop = nrow(dds_gut), returnData = TRUE) 
percentVar <- round(100 * attr(pcaPlot, "percentVar"))

plot12<- ggplot(pcaPlot, aes(PC1, PC2, color=New_Diet)) + 
  geom_point(aes(fill ="New_Diet" ),  size =2.5) + 
  geom_point(shape = 1, size = 2.5,colour = "black") +
  theme_bw() + ggtitle("Hindgut: Host transcriptomics") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("PC 1 [19 %]") + ylab("PC 2 [9 %]") + 
  stat_ellipse() + 
  scale_fill_manual(values = c("#984EA3", "#E41A1C")) + 
  scale_colour_manual( values = c("#984EA3", "#E41A1C"))+
  guides(color = guide_legend(title = "Diet")) 
```



# Metatranscriptomics
```{r}
# Specify the path to your RDS file on GitHub
base_url <- "https://raw.githubusercontent.com/shashank-KU/ImprovaFish-MDF-Effects/main/"

# Specify the paths to your files on GitHub
host_gut_rawCounts_url <- paste0(base_url, "Metatranscriptomics/high_dosage_trial/txi.kallisto.tsv")
sample_info_url <- paste0(base_url, "Metatranscriptomics/high_dosage_trial/sample_info.txt")

# Read the files
metatranscriptomics_data <- read.table(url(host_gut_rawCounts_url), header = T, row.names = 1, sep = "\t")
sample_info <- read.table(url(sample_info_url), header = T, row.names = 1, sep = "\t")


count_columns <- grep("counts\\.", names(metatranscriptomics_data), value = TRUE)
metatranscriptomics_data <- metatranscriptomics_data[count_columns]

colnames(metatranscriptomics_data) <- sub("counts.", "", colnames(metatranscriptomics_data))

r1 <- row.names(sample_info)
metatranscriptomics_data <- metatranscriptomics_data[, r1]
#all(colnames(metatranscriptomics_data) == rownames(sample_info))

# Hindgut
df <- round(metatranscriptomics_data) %>%
  # The next steps require a data frame and round() returns a matrix
  as.data.frame() %>%
  # Only keep rows that have total counts above the cutoff
  dplyr::filter(rowSums(.) >= 50)

all(colnames(df) == rownames(sample_info))

dds_metaT_gut <- DESeqDataSetFromMatrix(
  countData = df, # Our prepped data frame with counts
  colData = sample_info, # Data frame with annotation for our samples
  design = ~New_Diet # Here we are not specifying a model
)

dds_metaT_gut <- DESeq(dds_metaT_gut, parallel = T)
#resultsNames(dds_metaT_gut)
res <- results(dds_metaT_gut)
table(res$padj < 0.05)
#head(results(dds_metaT_gut, tidy=TRUE)) #let's look at the results table
#summary(res) #summary of results
res <- res[order(res$padj),]
#head(res)
#table(res$padj < 0.05)
res_tbl <- as_tibble(res, rownames = "ENSEMBL") %>%
  filter(padj <0.05)%>%
  arrange(padj)
```


```{r}
vsdata <- vst(dds_metaT_gut)
#plotPCA(vsdata, intgroup="New_Diet")  + stat_ellipse() + theme_bw()
pcaPlot <- DESeq2::plotPCA(vsdata, intgroup = c("New_Diet"), ntop = nrow(dds_metaT_gut), returnData = TRUE) 

plot13 <- ggplot(pcaPlot, aes(PC1, PC2, color=New_Diet)) + 
  geom_point(aes(fill ="New_Diet" ),  size =2.5) + 
  geom_point(shape = 1, size = 2.5,colour = "black") +
  theme_bw() + ggtitle("Hindgut: Metatranscriptomics") + 
  theme(plot.title = element_text(hjust = 0.5)) +
  xlab("PC 1 [11 %]") + ylab("PC 2 [4 %]") + 
  stat_ellipse()  + 
  scale_fill_manual(values = c("#984EA3", "#E41A1C")) + 
  scale_colour_manual( values = c("#984EA3", "#E41A1C"))+
  guides(color = guide_legend(title = "Diet")) 
```



```{r, fig.align='center', fig.height=12, fig.width=12}
left_pannel <- plot_grid(up_row, NULL, differential_heatmap_plot$gtable, align = 'hv', ncol = 1, rel_heights =  c(.6,0.1, 1), labels = c('', "G"))

right_pannel <- plot_grid(PCoA_bray_HG_plot, PCoA_bray_PC_plot, plot12, plot13,  align = "hv", ncol = 1, rel_widths = c(1,1,1,1), labels = c('D','E','F','H'))

plot_grid(left_pannel, right_pannel, align = "hv", rel_widths = c(1.2,1))

```

